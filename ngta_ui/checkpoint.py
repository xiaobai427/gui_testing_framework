# coding: utf-8

import enum
import contextlib
from typing import List, ClassVar, Optional
from .serialization import BaseModel, Field
from .errors import UnexpectedSuccessError, WarningError, FailureError, ErrorInfo

import logging
logger = logging.getLogger(__name__)


class CheckPoint(BaseModel):
    """
    Used to store checkpoint info.
    It would be generated by assert_that, pass_, fail_, warn_ automatically.
    """

    class Status(enum.IntEnum):
        NONE = 0
        PASSED = 1
        WARNING = 2
        FAILED = 3

    FailureError: ClassVar = FailureError
    WarningError: ClassVar = WarningError
    UnexpectedSuccessError: ClassVar = UnexpectedSuccessError

    name: str
    status: Status = Status.NONE
    error: Optional[ErrorInfo] = None
    images: List[str] = Field(default_factory=list)

    def __str__(self):
        return f"<CheckPoint(name:{self.name}, status: {self.status})>"

    @contextlib.contextmanager
    def catch(self):
        try:
            yield
        except (self.FailureError, self.WarningError) as err:
            is_failure = isinstance(err, self.FailureError)
            status = self.Status.FAILED if is_failure else self.Status.WARNING
            self.status = status
            self.error = ErrorInfo.from_exception(err)
            if not self.name:
                self.name = self.error.value

            if is_failure:
                raise
        else:
            self.status = self.Status.PASSED
        finally:
            if self.error:
                # add logging here, if capture FailureError in case._Outcome.execute, traceback will be wrong.
                logger.error(self.error.trace)
